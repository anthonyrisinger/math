# Copilot Instructions for Mathematical Modeling Projects

## Core Philosophy

You are working with a seasoned architect who values mathematical rigor over superficial appeal. The guiding principle is **pedagogical completeness, correctness, and authenticity**. Every implementation must be mathematically sound, theoretically grounded, and educationally valuable. Prefer substance over aesthetics, depth over breadth, and precision over approximation.

## Mathematical Standards

### Theoretical Foundations
- **Always ground implementations in established mathematical theory**
- Provide explicit mathematical formulations before any code implementation
- Include references to theoretical frameworks, papers, or mathematical principles
- Explain the "why" behind mathematical choices, not just the "how"
- Connect discrete implementations to their continuous theoretical counterparts

### Numerical Precision
- **Handle edge cases explicitly** (poles, singularities, overflow conditions)
- Use appropriate numerical stability techniques (log-space computation, regularization)
- Implement comprehensive error checking and graceful degradation
- Provide multiple computational pathways when precision is critical
- Always validate against known mathematical results

### Formula Documentation
```python
def mathematical_function(x):
    """
    Brief description with exact mathematical formulation.
    
    Mathematical Definition:
    f(x) = π^(x/2) / Γ(x/2 + 1)
    
    Theoretical Context:
    This represents the volume of a unit x-dimensional ball,
    extending the classical geometric concept to arbitrary real dimensions
    through the gamma function analytic continuation.
    
    Parameters
    ----------
    x : float or array-like
        Input dimension (can be fractional)
        
    Returns
    -------
    float or array
        Volume with proper handling of edge cases
        
    Notes
    -----
    Special cases:
    - f(0) = 1 (point volume)
    - f(2) = π (disk area)
    - f(3) = 4π/3 (sphere volume)
    
    References
    ----------
    Classical result via gamma function extension.
    """
```

## Code Architecture

### Module Organization
```
core/
├── constants.py      # Fundamental mathematical constants
├── gamma.py         # Gamma function family with numerical stability
├── measures.py      # Core geometric measures
├── phase.py         # Dynamic evolution systems
├── morphic.py       # Specialized mathematical structures
├── view.py          # Visualization utilities
└── __init__.py      # Clean public API
```

### API Design Principles
- **Expose a clean, mathematical API** through `__init__.py`
- Functions should accept both scalar and array inputs seamlessly
- Maintain mathematical naming conventions (prefer `ball_volume` over `vol`)
- Provide both low-level building blocks and high-level convenience functions
- Include verification and diagnostic utilities

### Error Handling
```python
# Preferred pattern for numerical stability
def safe_mathematical_operation(x):
    x = np.asarray(x)
    
    # Handle mathematical edge cases explicitly
    if np.any(x == 0):
        # Specific handling for poles/singularities
        pass
    
    # Use appropriate numerical techniques
    if np.any(np.abs(x) > OVERFLOW_THRESHOLD):
        # Log-space computation for large values
        pass
    
    # Validate output
    result = computation(x)
    assert np.all(np.isfinite(result[expected_finite_mask]))
    return result
```

## Documentation Standards

### Theoretical Context
Every mathematical concept should include:
- **Exact mathematical formulation** with proper notation
- **Theoretical significance** and connections to broader mathematics
- **Historical context** and key references when relevant
- **Computational considerations** and numerical challenges
- **Physical or geometric interpretation** when applicable

### Code Documentation
- **Comprehensive docstrings** following NumPy/SciPy conventions
- **Mathematical formulations** in docstrings using LaTeX-style notation
- **Parameter ranges and constraints** clearly specified
- **Return value interpretations** with units or meaning
- **Example usage** for complex functions

### README and Documentation Files
- **Start with the mathematical foundation** before implementation details
- **Include the complete theoretical framework** with proper mathematical notation
- **Show connections** between different mathematical concepts
- **Provide computational examples** that demonstrate theoretical principles
- **End with future directions** and research connections

## Testing Philosophy

### Mathematical Correctness
```python
def test_against_known_results():
    """Test against established mathematical results."""
    # Test exact values
    assert abs(gamma_safe(1.0) - 1.0) < 1e-15
    assert abs(ball_volume(2) - np.pi) < 1e-15
    
    # Test mathematical relationships
    for d in test_dimensions:
        assert abs(complexity_measure(d) - ball_volume(d) * sphere_surface(d)) < 1e-12
```

### Numerical Stability
```python
def test_edge_cases():
    """Test behavior at mathematical boundaries."""
    # Test poles and singularities
    assert np.isinf(gamma_safe(0.0))
    
    # Test large values
    large_result = ball_volume(100.0)
    assert np.isfinite(large_result) or large_result == 0.0
    
    # Test array handling
    mixed_input = np.array([0, 1, 2, np.inf])
    result = safe_function(mixed_input)
    assert len(result) == len(mixed_input)
```

### Theoretical Consistency
- **Cross-verify results** using multiple computational methods
- **Test mathematical relationships** (e.g., derivatives, integrals, identities)
- **Verify conservation laws** in dynamic systems
- **Check dimensional analysis** and unit consistency
- **Validate against analytical solutions** where available

## Visualization Principles

### Mathematical Authenticity
- **Visualizations must accurately represent the underlying mathematics**
- Prefer mathematical precision over visual appeal
- Include proper axis labels, mathematical notation, and scale information
- Show critical points, boundaries, and mathematical features explicitly
- Provide interactive elements that reveal mathematical structure

### Educational Value
```python
def create_educational_plot(mathematical_function, title="Mathematical Concept"):
    """Create a plot that teaches the mathematical concept."""
    fig, ax = plt.subplots(figsize=(10, 6))
    
    # Mathematical range appropriate to the concept
    x = np.linspace(mathematical_domain_start, mathematical_domain_end, 1000)
    y = mathematical_function(x)
    
    # Core mathematical curve
    ax.plot(x, y, 'b-', linewidth=2, label='f(x)')
    
    # Mark critical points mathematically
    critical_points = find_critical_points(mathematical_function)
    ax.scatter(*critical_points, color='red', s=100, zorder=5, label='Critical Points')
    
    # Mathematical annotations
    ax.set_xlabel('Dimension d', fontsize=12)
    ax.set_ylabel('f(d)', fontsize=12)
    ax.set_title(f'{title}\nf(d) = mathematical_formula', fontsize=14)
    
    # Show mathematical features
    ax.grid(True, alpha=0.3)
    ax.legend()
    
    return fig, ax
```

### Computational Visualization
- **Show convergence behavior** and numerical properties
- **Illustrate mathematical relationships** between different concepts
- **Demonstrate parameter sensitivity** and stability regions
- **Provide diagnostic plots** for numerical algorithms
- **Include mathematical validation** within visualizations

## Research Methodology

### Theoretical Development
1. **Start with mathematical foundations** - establish rigorous theoretical framework
2. **Identify key mathematical relationships** - find the core equations and principles
3. **Develop computational methods** - create numerically stable implementations
4. **Cross-validate thoroughly** - test against known results and theoretical predictions
5. **Explore extensions** - investigate generalizations and connections to other areas

### Implementation Strategy
1. **Build core mathematical primitives first** (gamma functions, basic measures)
2. **Compose higher-level concepts** from validated primitives
3. **Implement comprehensive testing** alongside core functionality
4. **Add visualization and diagnostic tools** for mathematical insight
5. **Document theoretical connections** and research implications

### Quality Assurance
- **Every mathematical claim must be verifiable**
- **Every numerical result must be reproducible**
- **Every implementation must handle edge cases**
- **Every function must have comprehensive tests**
- **Every concept must have clear theoretical grounding**

## Communication Style

### Mathematical Discourse
- Use **precise mathematical language** and established terminology
- **Explain mathematical intuition** alongside formal definitions  
- **Connect abstract concepts** to concrete computational examples
- **Acknowledge limitations** and areas of ongoing development
- **Reference established literature** and theoretical foundations

### Code Comments
```python
# Mathematical context: This implements the Weierstrass factorization
# for the gamma function, providing numerical stability near poles
def robust_gamma_computation(z):
    # Theoretical justification for the computational approach
    pass
```

### Problem-Solving Approach
- **Begin with mathematical analysis** before implementation
- **Identify theoretical constraints** and computational challenges
- **Design solutions that respect mathematical structure**
- **Validate through multiple independent methods**
- **Document the mathematical reasoning** behind implementation choices

## Integration Standards

### Cross-Module Consistency
- **Mathematical constants** should be defined once and imported everywhere
- **Numerical tolerances** should be consistent across all modules
- **Function naming** should follow mathematical conventions
- **Error handling patterns** should be uniform
- **Documentation style** should be consistent throughout

### External Dependencies
- **Prefer established scientific libraries** (NumPy, SciPy, SymPy)
- **Avoid unnecessary dependencies** that don't add mathematical value
- **Implement critical mathematical functions** independently when needed for precision
- **Use external libraries** for visualization and standard algorithms
- **Document mathematical reasons** for dependency choices

## Long-term Vision

### Research Integration
This codebase should serve as a **foundation for mathematical research**, not just a collection of utilities. Every implementation should be designed to:
- **Enable mathematical discovery** through computational exploration
- **Support theoretical development** with numerical validation
- **Facilitate educational understanding** through clear implementations
- **Connect to broader mathematical landscape** through proper abstractions

### Pedagogical Impact
The code should be **exemplary in its mathematical pedagogy**:
- **Self-documenting** through clear mathematical structure
- **Educationally complete** with full theoretical context
- **Computationally honest** about numerical limitations and assumptions
- **Mathematically rigorous** without sacrificing accessibility

---

*Remember: You are building mathematical infrastructure that must stand up to rigorous scrutiny while remaining accessible to those learning the concepts. Every line of code is a mathematical statement that must be defensible.*
